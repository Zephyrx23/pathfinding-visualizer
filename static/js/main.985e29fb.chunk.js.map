{"version":3,"sources":["images/weight.png","components/Node.js","components/Grid.js","algorithms/dijkstra.js","App.js","algorithms/depthFirstSearch.js","algorithms/breadthFirstSearch.js","index.js"],"names":["module","exports","Node","row","col","grid","setGrid","mousePressed","setMousePressed","clickType","useState","type","nodeType","setType","useEffect","setWall","newType","isWall","weight","setWeight","id","className","onMouseEnter","onMouseDown","console","log","onMouseUp","newGrid","slice","src","weightIcon","alt","Row","map","node","rowIdx","key","Grid","colIdx","unpackGrid","nodes","push","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","closestNode","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","newDistance","previousNode","neighbors","length","filter","isVisited","START_NODE","COL_SIZE","TARGET_NODE","ROW_SIZE","initializeGrid","currRow","createNode","getType","isStartOrTargetNode","backtrackPath","targetNode","shortestPath","currentNode","unshift","App","isAnimating","setIsAnimating","algo","setAlgo","setClickType","tempGrid","animateUnweighted","visitedNodes","success","i","setTimeout","animateShortestPath","animationCleanup","document","getElementById","getNewStartTargetGrid","JSON","parse","stringify","calculateDijkstra","startNode","visitedNodesInOrder","shift","dijkstra","calculateAlgo","algorithm","resetGridWithWalls","pop","depthFirstSearch","calculateDFS","breadthFirstSearch","calculateBFS","window","alert","classType","SplitButton","variant","title","disabled","onClick","Dropdown","Item","eventKey","Button","onMouseLeave","ReactDOM","render"],"mappings":"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","file":"static/js/main.985e29fb.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/weight.06a87e94.png\";","import React, { useState, useEffect } from 'react'\nimport weightIcon from '../images/weight.png'\n\n\nconst Node = ({row, col, grid, setGrid, mousePressed, setMousePressed, clickType}) => {\n    const [ nodeType, setType ] = useState(grid[row][col].type)\n\n    useEffect(() => {\n        setType(grid[row][col].type)\n    },[grid, row, col])\n    \n    const handleMouseDown = () => {\n        console.log(`Type: ${nodeType} Row: ${row} Col: ${col}`);\n        clickType === \"Wall\" ? setWall() : setWeight();\n        setMousePressed(true)\n    }\n\n    const handleMouseUp = () => {\n        const newGrid = grid.slice()\n        setGrid(newGrid)\n        setMousePressed(false)\n    }\n\n    const handleMouseEnter = () => {\n        if (mousePressed) {\n            clickType === \"Wall\" ? setWall() : setWeight();\n        }\n    }\n\n    const setWall = () => {\n        if (nodeType !== \"START\" && nodeType !== \"TARGET\") {\n            const newType = nodeType === \"WALL\" ? \"NODE\" : \"WALL\"\n            grid[row][col].type = newType\n            grid[row][col].isWall = !grid[row][col].isWall\n            grid[row][col].weight = newType === \"WEIGHT\" ? 2 : 1\n            setType(newType)\n        }\n    }\n\n    const setWeight = () => {\n        if (nodeType !== \"START\" && nodeType !== \"TARGET\") {\n            const newType = nodeType === \"WEIGHT\" ? \"NODE\" : \"WEIGHT\"\n            grid[row][col].type = newType\n            grid[row][col].weight = newType === \"WEIGHT\" ? 4 : 1\n            setType(newType)\n        }\n    }\n\n    return(\n        <div\n            id={`${row}-${col}`}\n            className={nodeType}\n            onMouseEnter={handleMouseEnter}\n            onMouseDown={handleMouseDown}\n            onMouseUp={handleMouseUp}\n        >\n            {nodeType === \"WEIGHT\" ? <img className=\"img\" src={weightIcon} alt=\"weight\" ></img> : \"\"}\n        </div>\n    )\n}\n\nexport default Node","import React from 'react'\nimport Node from \"./Node.js\";\n\nconst Row = ({col, grid, setGrid, mousePressed, setMousePressed, clickType}) => {\n    return(\n        <div>\n            {col.map((node, rowIdx) => {\n                // if (node.type === \"WALL\") {\n                //     console.log(`Row: ${node.row}, Col: ${node.col} is WALL`);\n                // }\n                return (<Node\n                    key={rowIdx}\n                    row={node.row}\n                    col={node.col}\n                    grid={grid}\n                    setGrid={setGrid}\n                    mousePressed={mousePressed}\n                    setMousePressed={setMousePressed}\n                    clickType={clickType}\n                />)\n            })}\n        </div>\n    )\n}\n\nconst Grid = ({grid, setGrid, mousePressed, setMousePressed, clickType}) => {\n    \n    return (grid.map((col, colIdx) => {\n            return (<Row \n                key={colIdx}\n                col={col} \n                grid={grid}\n                setGrid={setGrid}\n                mousePressed={mousePressed}\n                setMousePressed={setMousePressed}\n                clickType={clickType}\n            /> )\n        })\n    )\n}\n\nexport default Grid","export default function dijkstra(grid, startNode) {\n    const visitedNodesInOrder = []\n    startNode.distance = 0\n    const unvisitedNodes = unpackGrid(grid)\n\n    while (unvisitedNodes.length !== 0) {\n        sortNodesByDistance(unvisitedNodes) // Maintain a priority queue\n        const closestNode = unvisitedNodes.shift()\n\n        if (closestNode.isWall) continue\n        if (closestNode.distance === 99999) return [visitedNodesInOrder, false]\n        \n        closestNode.isVisited = true\n        visitedNodesInOrder.push(closestNode)\n        if (closestNode.type === \"TARGET\") {\n            startNode.previousNode = null;\n            return [visitedNodesInOrder, true]\n        }\n        updateUnvisitedNeighbors(closestNode, grid)\n    }\n}\n\nconst unpackGrid = (grid) => {\n    const nodes = []\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node)\n        }\n    }\n  return nodes\n}\n\nconst sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\n}\n\nconst updateUnvisitedNeighbors = (closestNode, grid) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        const newDistance = closestNode.distance + neighbor.weight;\n        if (newDistance < neighbor.distance) {\n            neighbor.distance = newDistance\n            neighbor.previousNode = closestNode\n        }\n    }\n}\n\nconst getUnvisitedNeighbors = (node, grid) => {\n    const neighbors = []\n    const {col, row} = node\n\n    if (row > 0)                    neighbors.push(grid[row - 1][col])\n    if (row < grid.length - 1)      neighbors.push(grid[row + 1][col])\n    if (col > 0)                    neighbors.push(grid[row][col - 1])\n    if (col < grid[0].length - 1)   neighbors.push(grid[row][col + 1])\n    return neighbors.filter(neighbor => !neighbor.isVisited)\n}","import React, { useState } from 'react'\nimport Grid from './components/Grid'\nimport depthFirstSearch from './algorithms/depthFirstSearch.js'\nimport breadthFirstSearch from './algorithms/breadthFirstSearch.js'\nimport dijkstra from './algorithms/dijkstra.js'\nimport Button from 'react-bootstrap/Button'\nimport SplitButton from 'react-bootstrap/SplitButton'\nimport DropdownButton from 'react-bootstrap/DropdownButton'\nimport Dropdown from 'react-bootstrap/Dropdown'\nimport './components/Node.css'\nimport './App.css'\n\nconst ROW_SIZE    = 40 // I'll have to scale size with browser size ughhhhhhh\nconst COL_SIZE    = 26\nconst START_NODE  = {col: 5, row: COL_SIZE/2}\nconst TARGET_NODE = {col: ROW_SIZE-6, row: COL_SIZE/2}\n\nconst App = () => {\n    const [ grid, setGrid ]                 = useState(initializeGrid())\n    const [ mousePressed, setMousePressed ] = useState(false)\n    const [ isAnimating, setIsAnimating ]   = useState(false)\n    const [ algo, setAlgo ]                 = useState(\"Select an algorithm\")\n    const [ clickType, setClickType ]       = useState(\"Wall\")\n    let tempGrid = grid\n\n    const handleMouseUp = () => {\n        const newGrid = tempGrid.slice()\n        setGrid(newGrid)\n        setMousePressed(false)\n    }\n\n    const animateUnweighted = (visitedNodes, shortestPath, success) => {\n        for (let i = 1; i < visitedNodes.length; i++) {\n            if (i === visitedNodes.length-1 && success) {\n                setTimeout(() => {\n                    if (success) {\n                        animateShortestPath(shortestPath);\n                    } else {\n                        animationCleanup()\n                    }\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodes[i];\n                document.getElementById(`${node.row}-${node.col}`).className =\n                    'NODE-visited';\n                if (i === visitedNodes.length-1) animationCleanup()\n            }, 10 * i);\n          }\n    }\n\n    const animateShortestPath = (shortestPath) => {\n        for (let i = 1; i < shortestPath.length-1; i++) {\n            setTimeout(() => {\n              const node = shortestPath[i];\n              if (!isStartOrTargetNode(node.row, node.col)) {\n                document.getElementById(`${node.row}-${node.col}`).className =\n                    'NODE-shortest-path';\n              }\n              if (i === shortestPath.length-2) {\n                animationCleanup()\n              }\n            }, 50 * i);\n          }\n    }\n\n    const animationCleanup = () => {\n        setIsAnimating(false)\n    }\n\n    const getNewStartTargetGrid = () => {\n        const newGrid = JSON.parse(JSON.stringify(grid));\n        const startNode = newGrid[START_NODE.row][START_NODE.col]\n        const targetNode = newGrid[TARGET_NODE.row][TARGET_NODE.col]\n        return [newGrid, startNode, targetNode];\n    }\n\n    const calculateDFS = () => {\n        const [newGrid, startNode, targetNode] = getNewStartTargetGrid()\n        const [visitedNodes, success] = depthFirstSearch(newGrid, startNode)\n        const shortestPath = backtrackPath(targetNode)\n        animateUnweighted(visitedNodes, shortestPath, success)\n    }\n\n    const calculateBFS = () => {\n        const [newGrid, startNode, targetNode] = getNewStartTargetGrid()\n        const [visitedNodes, success] = breadthFirstSearch(newGrid, startNode)\n        const shortestPath = backtrackPath(targetNode)\n        animateUnweighted(visitedNodes, shortestPath, success)\n    }\n\n    const calculateDijkstra = () => {\n        const [newGrid, startNode, targetNode] = getNewStartTargetGrid()\n        const [visitedNodes, success] = dijkstra(newGrid, startNode)\n        const shortestPath = backtrackPath(targetNode)\n        animateUnweighted(visitedNodes, shortestPath, success)\n    }\n\n    const calculateAlgo = (algorithm) => {\n        setIsAnimating(true)\n        resetGridWithWalls()\n        switch (algorithm) {\n            case \"Depth First Search\":\n                calculateDFS()\n                break;\n            case \"Breadth First Search\":\n                calculateBFS()\n                break;\n            case \"Dijkstra's Algorithm\":\n                calculateDijkstra()\n                break;\n            default:\n                window.alert(\"Please select an algorithm\")\n                setIsAnimating(false)\n                break;\n        }\n    }\n\n    const resetGrid = () => {\n        setGrid(initializeGrid())\n        for (let row = 0; row < COL_SIZE; row++) {\n            for (let col = 0; col < ROW_SIZE; col++) {\n                if (!isStartOrTargetNode(row, col)) {\n                    document.getElementById(`${row}-${col}`).className =\n                        'NODE';\n                }\n            }\n        }  \n    }\n\n    const resetGridWithWalls = () => {\n        for (let row = 0; row < COL_SIZE; row++) {\n            for (let col = 0; col < ROW_SIZE; col++) {\n                const classType = document.getElementById(`${row}-${col}`).className;\n                if (classType === 'NODE-visited' || classType === 'NODE-shortest-path') {\n                    document.getElementById(`${row}-${col}`).className =\n                        'NODE';\n                }\n            }\n        }  \n    }\n\n    return (\n        <>\n        <SplitButton\n          variant=\"primary\"\n          title={isAnimating ? \"In Progress...\" : algo}\n          disabled={isAnimating}\n          onClick={() => calculateAlgo(algo)}\n        >\n            <Dropdown.Item eventKey=\"1\" onClick={() => setAlgo(\"Depth First Search\")}>\n                Depth First Search\n            </Dropdown.Item>\n            <Dropdown.Item eventKey=\"2\" onClick={() => setAlgo(\"Breadth First Search\")}>\n                Breadth First Search\n            </Dropdown.Item>\n            <Dropdown.Item eventKey=\"3\" onClick={() => setAlgo(\"Dijkstra's Algorithm\")}>\n                Dijkstra's Algorithm\n            </Dropdown.Item>\n        </SplitButton>\n        <SplitButton\n          variant=\"info\"\n          title={clickType}\n          disabled={isAnimating}\n        >\n            <Dropdown.Item eventKey=\"1\" onClick={() => setClickType(\"Wall\")}>\n                Wall\n            </Dropdown.Item>\n            <Dropdown.Item eventKey=\"2\" onClick={() => setClickType(\"Weight\")}>\n                Weight\n            </Dropdown.Item>\n        </SplitButton>\n        <Button variant=\"secondary\" onClick={resetGrid} disabled={isAnimating}>Reset</Button>\n        <div className=\"App\" onMouseLeave={handleMouseUp}>            \n            <Grid \n                grid={tempGrid} \n                setGrid={setGrid}\n                mousePressed={mousePressed}\n                setMousePressed={setMousePressed}\n                clickType={clickType}\n            />\n        </div>\n        </>\n    )\n}\n\nconst initializeGrid = () => {\n    const grid = []\n    for (let row = 0; row < COL_SIZE; row++) {\n        const currRow = []\n        for (let col = 0; col < ROW_SIZE; col++) {\n            currRow.push(createNode(row, col))\n        }\n        grid.push(currRow)\n    }\n    return(grid)\n}\n\n/*\n    TODO: Add weight property, on press, displays weight of node\n*/\nconst createNode= (row, col) => {\n    return ({\n        row:          row,\n        col:          col,\n        type:         getType(row, col),\n        isVisited:    false,\n        isWall:       false,\n        previousNode: null,\n        distance:     99999,\n        weight:       1,\n    })\n}\n\nconst getType = (row, col) => {\n    return(\n        START_NODE.row === row && START_NODE.col === col ? \"START\" :\n        TARGET_NODE.row === row && TARGET_NODE.col === col ? \"TARGET\" : \"NODE\"\n    )\n}\n\nconst isStartOrTargetNode = (row, col)  => {\n    return (row === START_NODE.row  && col === START_NODE.col) \n        || (row === TARGET_NODE.row && col === TARGET_NODE.col);\n}\n\nfunction backtrackPath(targetNode) {\n    const shortestPath = []\n    let currentNode = targetNode\n    while (currentNode !== null) {\n        shortestPath.unshift(currentNode)\n        currentNode = currentNode.previousNode\n    } \n\n    return shortestPath;\n}\n\nexport default App\n","export default function depthFirstSearch(grid, startNode, ROW_SIZE, COL_SIZE) {\n    const visitedNodes = []\n    const visitedNodesInOrder = []\n    visitedNodes.push(startNode)\n\n\n    while (visitedNodes.length !== 0) {\n        const currentNode = visitedNodes.pop()\n        if (currentNode.isWall || currentNode.isVisited) {\n            continue\n        }\n\n        visitedNodesInOrder.push(currentNode)\n\n        if (currentNode.type === \"TARGET\") {\n            // console.log(`Visited Nodes: ${visitedNodesInOrder}`);\n            startNode.previousNode = null;\n            return ([visitedNodesInOrder, true])\n        }\n        \n        currentNode.isVisited = true\n        const row = currentNode.row\n        const col = currentNode.col\n        // console.log(`Row ${row} Col: ${col}`);\n\n        const neighbors = []\n        if (!(col-1 < 0))               neighbors.push(grid[row][col-1])\n        if (!(row+1 > grid.length-1))   neighbors.push(grid[row+1][col])\n        if (!(col+1 > grid[0].length-1)) neighbors.push(grid[row][col+1])\n        if (!(row-1 < 0))               neighbors.push(grid[row-1][col])\n\n        for (const neighbor of neighbors) {\n            visitedNodes.push(neighbor)\n            if (neighbor.previousNode == null) {\n                neighbor.previousNode = currentNode\n            }\n        }\n    }\n\n    return ([visitedNodesInOrder, false])\n}","export default function breadthFirstSearch(grid, startNode, ROW_SIZE, COL_SIZE) {\n    const visitedNodes = []\n    const visitedNodesInOrder = []\n    visitedNodes.push(startNode)\n\n\n    while (visitedNodes.length !== 0) {\n        const currentNode = visitedNodes.shift()\n        if (currentNode.isWall || currentNode.isVisited) {\n            continue\n        }\n\n        visitedNodesInOrder.push(currentNode)\n\n        if (currentNode.type === \"TARGET\") {\n            // console.log(`Visited Nodes: ${visitedNodesInOrder}`);\n            startNode.previousNode = null;\n            return ([visitedNodesInOrder, true])\n        }\n        \n        currentNode.isVisited = true\n        const row = currentNode.row\n        const col = currentNode.col\n        // console.log(`Row ${row} Col: ${col}`);\n\n        const neighbors = []\n        if (!(col-1 < 0))               neighbors.push(grid[row][col-1])\n        if (!(row+1 > grid.length-1))   neighbors.push(grid[row+1][col])\n        if (!(col+1 > grid[0].length-1)) neighbors.push(grid[row][col+1])\n        if (!(row-1 < 0))               neighbors.push(grid[row-1][col])\n\n        for (const neighbor of neighbors) {\n            visitedNodes.push(neighbor)\n            if (neighbor.previousNode == null) {\n                neighbor.previousNode = currentNode\n            }\n        }\n    }\n\n    return ([visitedNodesInOrder, false])\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'bootstrap/dist/css/bootstrap.min.css'\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}