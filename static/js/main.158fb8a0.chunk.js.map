{"version":3,"sources":["images/weight.png","components/Node.js","components/Grid.js","components/Parameters.js","algorithms/dijkstra.js","algorithms/a*Search.js","App.js","algorithms/depthFirstSearch.js","algorithms/breadthFirstSearch.js","index.js"],"names":["module","exports","Node","row","col","grid","setGrid","mousePressed","setMousePressed","clickType","useState","type","nodeType","setType","useEffect","setWall","newType","isWall","weight","setWeight","id","className","onMouseEnter","onMouseDown","console","log","onMouseUp","newGrid","slice","src","weightIcon","alt","Row","map","node","rowIdx","key","Grid","colIdx","Parameters","isAnimating","algo","setAlgo","showAlgoInfo","setShowAlgoInfo","setClickType","showTypeInfo","setShowTypeInfo","SplitButton","variant","title","disabled","onClick","Dropdown","Header","Item","eventKey","Divider","Modal","size","show","onHide","closeButton","Title","Body","unpackGrid","nodes","push","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","closestNode","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","newDistance","previousNode","neighbors","length","filter","isVisited","manhattanDist","targetNode","Math","abs","fScore","newfScore","START_NODE","COL_SIZE","TARGET_NODE","ROW_SIZE","initializeGrid","currRow","createNode","getType","isStartOrTargetNode","backtrackPath","shortestPath","currentNode","unshift","App","setIsAnimating","tempGrid","animateUnweighted","visitedNodes","success","i","setTimeout","animateShortestPath","animationCleanup","document","getElementById","getNewStartTargetGrid","JSON","parse","stringify","calculateDijkstra","startNode","visitedNodesInOrder","shift","dijkstra","calculateAStartSearch","heuristic","aStarSearch","calculateAlgo","algorithm","resetAnimatedGrid","pop","depthFirstSearch","calculateDFS","breadthFirstSearch","calculateBFS","window","alert","classType","Button","onMouseLeave","ReactDOM","render"],"mappings":"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","file":"static/js/main.158fb8a0.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/weight.06a87e94.png\";","import React, { useState, useEffect } from 'react'\nimport weightIcon from '../images/weight.png'\n\n\nconst Node = ({row, col, grid, setGrid, mousePressed, setMousePressed, clickType}) => {\n    const [ nodeType, setType ] = useState(grid[row][col].type)\n\n    useEffect(() => {\n        setType(grid[row][col].type)\n    },[grid, row, col])\n    \n    const handleMouseDown = () => {\n        console.log(`Type: ${nodeType} Row: ${row} Col: ${col}`);\n        clickType === \"Wall\" ? setWall() : setWeight();\n        setMousePressed(true)\n    }\n\n    const handleMouseUp = () => {\n        const newGrid = grid.slice()\n        setGrid(newGrid)\n        setMousePressed(false)\n    }\n\n    const handleMouseEnter = () => {\n        if (mousePressed) {\n            clickType === \"Wall\" ? setWall() : setWeight();\n        }\n    }\n\n    const setWall = () => {\n        if (nodeType !== \"START\" && nodeType !== \"TARGET\") {\n            const newType = nodeType === \"WALL\" ? \"NODE\" : \"WALL\"\n            grid[row][col].type = newType\n            grid[row][col].isWall = !grid[row][col].isWall\n            grid[row][col].weight = newType === \"WEIGHT\" ? 2 : 1\n            setType(newType)\n        }\n    }\n\n    const setWeight = () => {\n        if (nodeType !== \"START\" && nodeType !== \"TARGET\") {\n            const newType = nodeType === \"WEIGHT\" ? \"NODE\" : \"WEIGHT\"\n            grid[row][col].type = newType\n            grid[row][col].weight = newType === \"WEIGHT\" ? 8 : 1\n            setType(newType)\n        }\n    }\n\n    return(\n        <div\n            id={`${row}-${col}`}\n            className={nodeType}\n            onMouseEnter={handleMouseEnter}\n            onMouseDown={handleMouseDown}\n            onMouseUp={handleMouseUp}\n        >\n            {nodeType === \"WEIGHT\" ? <img className=\"img\" src={weightIcon} alt=\"weight\" ></img> : \"\"}\n        </div>\n    )\n}\n\nexport default Node","import React from 'react'\nimport Node from \"./Node.js\";\n\nconst Row = ({col, grid, setGrid, mousePressed, setMousePressed, clickType}) => {\n    return(\n        <div>\n            {col.map((node, rowIdx) => {\n                // if (node.type === \"WALL\") {\n                //     console.log(`Row: ${node.row}, Col: ${node.col} is WALL`);\n                // }\n                return (<Node\n                    key={rowIdx}\n                    row={node.row}\n                    col={node.col}\n                    grid={grid}\n                    setGrid={setGrid}\n                    mousePressed={mousePressed}\n                    setMousePressed={setMousePressed}\n                    clickType={clickType}\n                />)\n            })}\n        </div>\n    )\n}\n\nconst Grid = ({grid, setGrid, mousePressed, setMousePressed, clickType}) => {\n    \n    return (grid.map((col, colIdx) => {\n            return (<Row \n                key={colIdx}\n                col={col} \n                grid={grid}\n                setGrid={setGrid}\n                mousePressed={mousePressed}\n                setMousePressed={setMousePressed}\n                clickType={clickType}\n            /> )\n        })\n    )\n}\n\nexport default Grid","import React from 'react'\nimport SplitButton from 'react-bootstrap/SplitButton'\nimport Dropdown from 'react-bootstrap/Dropdown'\nimport Modal from 'react-bootstrap/Modal'\n\nconst Parameters = ({isAnimating, algo, setAlgo, showAlgoInfo, setShowAlgoInfo, \n        clickType, setClickType, showTypeInfo, setShowTypeInfo}) => {\n    return(\n        <>\n        <SplitButton\n          variant=\"info\"\n          title={isAnimating ? \"In Progress...\" : algo}\n          disabled={isAnimating}\n          onClick={() => setShowAlgoInfo(true)}\n        >\n            <Dropdown.Header>Unweighted Algorithms</Dropdown.Header>\n            <Dropdown.Item eventKey=\"1\" onClick={() => setAlgo(\"Depth First Search\")}>\n                Depth First Search\n            </Dropdown.Item>\n            <Dropdown.Item eventKey=\"2\" onClick={() => setAlgo(\"Breadth First Search\")}>\n                Breadth First Search\n            </Dropdown.Item>\n            <Dropdown.Divider />\n            <Dropdown.Header>Weighted Algorithms</Dropdown.Header>\n            <Dropdown.Item eventKey=\"3\" onClick={() => setAlgo(\"Dijkstra's Algorithm\")}>\n                Dijkstra's Algorithm\n            </Dropdown.Item>\n            <Dropdown.Item eventKey=\"3\" onClick={() => setAlgo(\"A* Search\")}>\n                A* Search\n            </Dropdown.Item>\n        </SplitButton>\n        <Modal size=\"lg\" show={showAlgoInfo} onHide={() => setShowAlgoInfo(false)}>\n            <Modal.Header closeButton>\n            <Modal.Title>Algorithms</Modal.Title>\n            </Modal.Header>\n            <Modal.Body>Select an pathfinding algorithm from the dropdown. <br /><br />\n                Note that unweighted algorithms (Depth First Search, Breadth First Search) will not take into account any weights placed on the field.<br /><br />\n                Weighted algorithms have a cost of 1 to travel to any adjacent node and a cost 8 to travel to a weighted one. \n                These will calculate the shortest path to get to the target, minimizing the total cost to get there.\n            </Modal.Body>\n        </Modal>\n        <SplitButton\n          variant=\"info\"\n          title={clickType}\n          disabled={isAnimating}\n          onClick={() => setShowTypeInfo(true)}\n        >\n            <Dropdown.Item eventKey=\"1\" onClick={() => setClickType(\"Wall\")}>\n                Wall\n            </Dropdown.Item>\n            <Dropdown.Item eventKey=\"2\" onClick={() => setClickType(\"Weight\")}>\n                Weight\n            </Dropdown.Item>\n        </SplitButton>\n        <Modal size=\"lg\" show={showTypeInfo} onHide={() => setShowTypeInfo(false)}>\n            <Modal.Header closeButton>\n            <Modal.Title>Wall/Weight Interation</Modal.Title>\n            </Modal.Header>\n            <Modal.Body>Click and hold on any node to create/remove walls or weights. <br />\n                Walls cannot be traversed by the path while weights can be travsered. <br /><br />\n                Weights \"cost\" more to travel to where the default cost to travel to an adjacent node is 1.\n                To be specific, it costs 8 to travel to a weighted node. \n                Weights will only work with weighted algorithms.\n            </Modal.Body>\n        </Modal>\n        </>\n    )\n}\n\nexport default Parameters","export default function dijkstra(grid, startNode) {\n    const visitedNodesInOrder = []\n    startNode.distance = 0\n    const unvisitedNodes = unpackGrid(grid)\n\n    while (unvisitedNodes.length !== 0) {\n        sortNodesByDistance(unvisitedNodes) // Maintain a priority queue\n        const closestNode = unvisitedNodes.shift()\n\n        if (closestNode.isWall) continue\n        if (closestNode.distance === 99999) return [visitedNodesInOrder, false]\n        \n        closestNode.isVisited = true\n        visitedNodesInOrder.push(closestNode)\n        if (closestNode.type === \"TARGET\") {\n            startNode.previousNode = null;\n            return [visitedNodesInOrder, true]\n        }\n        updateUnvisitedNeighbors(closestNode, grid)\n    }\n}\n\nconst unpackGrid = (grid) => {\n    const nodes = []\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node)\n        }\n    }\n  return nodes\n}\n\nconst sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\n}\n\nconst updateUnvisitedNeighbors = (closestNode, grid) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        const newDistance = closestNode.distance + neighbor.weight;\n        if (newDistance < neighbor.distance) {\n            neighbor.distance = newDistance\n            neighbor.previousNode = closestNode\n        }\n    }\n}\n\nconst getUnvisitedNeighbors = (node, grid) => {\n    const neighbors = []\n    const {col, row} = node\n\n    if (row > 0)                    neighbors.push(grid[row - 1][col])\n    if (row < grid.length - 1)      neighbors.push(grid[row + 1][col])\n    if (col > 0)                    neighbors.push(grid[row][col - 1])\n    if (col < grid[0].length - 1)   neighbors.push(grid[row][col + 1])\n    return neighbors.filter(neighbor => !neighbor.isVisited)\n}","export default function aStarSearch(grid, startNode, targetNode) {\n    const visitedNodesInOrder = []\n    startNode.distance = 0\n    startNode.heuristic = manhattanDist(startNode, targetNode)\n    startNode.fScore = startNode.distance + startNode.heuristic\n    const unvisitedNodes = unpackGrid(grid)\n\n    while (unvisitedNodes.length !== 0) {\n        sortNodesByDistance(unvisitedNodes) // Maintain a priority queue\n        const closestNode = unvisitedNodes.shift()\n\n        if (closestNode.isWall) continue\n        if (closestNode.distance === 99999) return [visitedNodesInOrder, false]\n        \n        closestNode.isVisited = true\n        visitedNodesInOrder.push(closestNode)\n        if (closestNode.type === \"TARGET\") {\n            startNode.previousNode = null;\n            return [visitedNodesInOrder, true]\n        }\n        updateUnvisitedNeighbors(closestNode, targetNode, grid)\n    }\n}\n\nconst unpackGrid = (grid) => {\n    const nodes = []\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node)\n        }\n    }\n  return nodes\n}\n\nconst manhattanDist = (node, targetNode) => {\n    let d1 = Math.abs (node.row - targetNode.row);\n    let d2 = Math.abs (node.col - targetNode.col);\n    return d1 + d2;\n}\n\nconst sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.fScore - nodeB.fScore)\n}\n\nconst updateUnvisitedNeighbors = (closestNode, targetNode, grid) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        const newDistance = closestNode.distance + neighbor.weight;\n        const newfScore = newDistance + manhattanDist(neighbor, targetNode); // f(x) = g(x) + h(x)\n        if (newfScore < neighbor.fScore) {\n            neighbor.distance = newDistance\n            neighbor.fScore = newfScore\n            neighbor.previousNode = closestNode\n        }\n    }\n}\n\nconst getUnvisitedNeighbors = (node, grid) => {\n    const neighbors = []\n    const {col, row} = node\n\n    if (row > 0)                    neighbors.push(grid[row - 1][col])\n    if (row < grid.length - 1)      neighbors.push(grid[row + 1][col])\n    if (col > 0)                    neighbors.push(grid[row][col - 1])\n    if (col < grid[0].length - 1)   neighbors.push(grid[row][col + 1])\n    return neighbors.filter(neighbor => !neighbor.isVisited)\n}","import React, { useState } from 'react'\nimport Grid from './components/Grid'\nimport Parameters from './components/Parameters'\nimport depthFirstSearch from './algorithms/depthFirstSearch.js'\nimport breadthFirstSearch from './algorithms/breadthFirstSearch.js'\nimport dijkstra from './algorithms/dijkstra.js'\nimport aStarSearch from './algorithms/a*Search.js'  \nimport Button from 'react-bootstrap/Button'\nimport './components/Node.css'\nimport './App.css'\n\nconst ROW_SIZE    = 40 // I'll have to scale size with browser size ughhhhhhh\nconst COL_SIZE    = 26\nconst START_NODE  = {col: 5, row: COL_SIZE/2}\nconst TARGET_NODE = {col: ROW_SIZE-6, row: COL_SIZE/2}\n\nconst App = () => {\n    const [ grid, setGrid ]                 = useState(initializeGrid())\n    const [ mousePressed, setMousePressed ] = useState(false)\n    const [ isAnimating, setIsAnimating ]   = useState(false)\n    const [ algo, setAlgo ]                 = useState(\"Select an algorithm\")\n    const [ clickType, setClickType ]       = useState(\"Wall\")\n    const [ showAlgoInfo, setShowAlgoInfo ] = useState(false)\n    const [ showTypeInfo, setShowTypeInfo ] = useState(false)\n    let tempGrid = grid\n\n    const handleMouseUp = () => {\n        const newGrid = tempGrid.slice()\n        setGrid(newGrid)\n        setMousePressed(false)\n    }\n\n    const animateUnweighted = (visitedNodes, shortestPath, success) => {\n        for (let i = 1; i < visitedNodes.length; i++) {\n            if (i === visitedNodes.length-1 && success) {\n                setTimeout(() => {\n                    if (success) {\n                        animateShortestPath(shortestPath);\n                    } else {\n                        animationCleanup()\n                    }\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodes[i];\n                document.getElementById(`${node.row}-${node.col}`).className =\n                    'NODE-visited';\n                if (i === visitedNodes.length-1) animationCleanup()\n            }, 10 * i);\n          }\n    }\n\n    const animateShortestPath = (shortestPath) => {\n        for (let i = 1; i < shortestPath.length-1; i++) {\n            setTimeout(() => {\n              const node = shortestPath[i];\n              if (!isStartOrTargetNode(node.row, node.col)) {\n                document.getElementById(`${node.row}-${node.col}`).className =\n                    'NODE-shortest-path';\n              }\n              if (i === shortestPath.length-2) {\n                animationCleanup()\n              }\n            }, 50 * i);\n          }\n    }\n\n    const animationCleanup = () => {\n        setIsAnimating(false)\n    }\n\n    const getNewStartTargetGrid = () => {\n        const newGrid = JSON.parse(JSON.stringify(grid));\n        const startNode = newGrid[START_NODE.row][START_NODE.col]\n        const targetNode = newGrid[TARGET_NODE.row][TARGET_NODE.col]\n        return [newGrid, startNode, targetNode];\n    }\n\n    const calculateDFS = () => {\n        const [newGrid, startNode, targetNode] = getNewStartTargetGrid()\n        const [visitedNodes, success] = depthFirstSearch(newGrid, startNode)\n        const shortestPath = backtrackPath(targetNode)\n        animateUnweighted(visitedNodes, shortestPath, success)\n    }\n\n    const calculateBFS = () => {\n        const [newGrid, startNode, targetNode] = getNewStartTargetGrid()\n        const [visitedNodes, success] = breadthFirstSearch(newGrid, startNode)\n        const shortestPath = backtrackPath(targetNode)\n        animateUnweighted(visitedNodes, shortestPath, success)\n    }\n\n    const calculateDijkstra = () => {\n        const [newGrid, startNode, targetNode] = getNewStartTargetGrid()\n        const [visitedNodes, success] = dijkstra(newGrid, startNode)\n        const shortestPath = backtrackPath(targetNode)\n        animateUnweighted(visitedNodes, shortestPath, success)\n    }\n\n    const calculateAStartSearch = () => {\n        const [newGrid, startNode, targetNode] = getNewStartTargetGrid()\n        const [visitedNodes, success] = aStarSearch(newGrid, startNode, targetNode)\n        console.log(visitedNodes)\n        const shortestPath = backtrackPath(targetNode)\n        animateUnweighted(visitedNodes, shortestPath, success)\n    }\n\n    const calculateAlgo = (algorithm) => {\n        setIsAnimating(true)\n        resetAnimatedGrid()\n        switch (algorithm) {\n            case \"Depth First Search\":\n                calculateDFS()\n                break;\n            case \"Breadth First Search\":\n                calculateBFS()\n                break;\n            case \"Dijkstra's Algorithm\":\n                calculateDijkstra()\n                break;\n            case \"A* Search\":\n                calculateAStartSearch()\n                break;\n            default:\n                window.alert(\"Please select an algorithm\")\n                setIsAnimating(false)\n                break;\n        }\n    }\n\n    const resetGrid = () => {\n        setGrid(initializeGrid())\n        for (let row = 0; row < COL_SIZE; row++) {\n            for (let col = 0; col < ROW_SIZE; col++) {\n                if (!isStartOrTargetNode(row, col)) {\n                    document.getElementById(`${row}-${col}`).className =\n                        'NODE';\n                }\n            }\n        }  \n    }\n\n    const resetAnimatedGrid = () => {\n        for (let row = 0; row < COL_SIZE; row++) {\n            for (let col = 0; col < ROW_SIZE; col++) {\n                const classType = document.getElementById(`${row}-${col}`).className;\n                if (classType === 'NODE-visited' || classType === 'NODE-shortest-path') {\n                    document.getElementById(`${row}-${col}`).className =\n                        'NODE';\n                }\n            }\n        }  \n    }\n\n    return (\n        <>\n        <Parameters\n            isAnimating={isAnimating}\n            algo={algo}\n            setAlgo={setAlgo}\n            showAlgoInfo={showAlgoInfo}\n            setShowAlgoInfo={setShowAlgoInfo} \n            clickType={clickType}\n            setClickType={setClickType}\n            showTypeInfo={showTypeInfo}\n            setShowTypeInfo={setShowTypeInfo}\n        />\n        <Button variant=\"primary\" onClick={() => calculateAlgo(algo)} disabled={isAnimating}>Animate Algorithm</Button>\n        <Button variant=\"secondary\" onClick={resetGrid} disabled={isAnimating}>Full Reset</Button>\n        <Button variant=\"secondary\" onClick={resetAnimatedGrid} disabled={isAnimating}>Reset Path</Button>\n        <div className=\"App\" onMouseLeave={handleMouseUp}>            \n            <Grid \n                grid={tempGrid} \n                setGrid={setGrid}\n                mousePressed={mousePressed}\n                setMousePressed={setMousePressed}\n                clickType={clickType}\n            />\n        </div>\n        </>\n    )\n}\n\nconst initializeGrid = () => {\n    const grid = []\n    for (let row = 0; row < COL_SIZE; row++) {\n        const currRow = []\n        for (let col = 0; col < ROW_SIZE; col++) {\n            currRow.push(createNode(row, col))\n        }\n        grid.push(currRow)\n    }\n    return(grid)\n}\n\n/*\n    TODO: Add weight property, on press, displays weight of node\n*/\nconst createNode= (row, col) => {\n    return ({\n        row:          row,\n        col:          col,\n        type:         getType(row, col),\n        isVisited:    false,\n        isWall:       false,\n        previousNode: null,\n        distance:     99999,\n        fScore:       99999,\n        weight:       1,\n    })\n}\n\nconst getType = (row, col) => {\n    return(\n        START_NODE.row === row && START_NODE.col === col ? \"START\" :\n        TARGET_NODE.row === row && TARGET_NODE.col === col ? \"TARGET\" : \"NODE\"\n    )\n}\n\nconst isStartOrTargetNode = (row, col)  => {\n    return (row === START_NODE.row  && col === START_NODE.col) \n        || (row === TARGET_NODE.row && col === TARGET_NODE.col);\n}\n\nfunction backtrackPath(targetNode) {\n    const shortestPath = []\n    let currentNode = targetNode\n    while (currentNode !== null) {\n        shortestPath.unshift(currentNode)\n        currentNode = currentNode.previousNode\n    } \n\n    return shortestPath;\n}\n\nexport default App\n","export default function depthFirstSearch(grid, startNode, ROW_SIZE, COL_SIZE) {\n    const visitedNodes = []\n    const visitedNodesInOrder = []\n    visitedNodes.push(startNode)\n\n\n    while (visitedNodes.length !== 0) {\n        const currentNode = visitedNodes.pop()\n        if (currentNode.isWall || currentNode.isVisited) {\n            continue\n        }\n\n        visitedNodesInOrder.push(currentNode)\n\n        if (currentNode.type === \"TARGET\") {\n            // console.log(`Visited Nodes: ${visitedNodesInOrder}`);\n            startNode.previousNode = null;\n            return ([visitedNodesInOrder, true])\n        }\n        \n        currentNode.isVisited = true\n        const row = currentNode.row\n        const col = currentNode.col\n        // console.log(`Row ${row} Col: ${col}`);\n\n        const neighbors = []\n        if (!(col-1 < 0))               neighbors.push(grid[row][col-1])\n        if (!(row+1 > grid.length-1))   neighbors.push(grid[row+1][col])\n        if (!(col+1 > grid[0].length-1)) neighbors.push(grid[row][col+1])\n        if (!(row-1 < 0))               neighbors.push(grid[row-1][col])\n\n        for (const neighbor of neighbors) {\n            visitedNodes.push(neighbor)\n            if (neighbor.previousNode == null) {\n                neighbor.previousNode = currentNode\n            }\n        }\n    }\n\n    return ([visitedNodesInOrder, false])\n}","export default function breadthFirstSearch(grid, startNode, ROW_SIZE, COL_SIZE) {\n    const visitedNodes = []\n    const visitedNodesInOrder = []\n    visitedNodes.push(startNode)\n\n\n    while (visitedNodes.length !== 0) {\n        const currentNode = visitedNodes.shift()\n        if (currentNode.isWall || currentNode.isVisited) {\n            continue\n        }\n\n        visitedNodesInOrder.push(currentNode)\n\n        if (currentNode.type === \"TARGET\") {\n            // console.log(`Visited Nodes: ${visitedNodesInOrder}`);\n            startNode.previousNode = null;\n            return ([visitedNodesInOrder, true])\n        }\n        \n        currentNode.isVisited = true\n        const row = currentNode.row\n        const col = currentNode.col\n        // console.log(`Row ${row} Col: ${col}`);\n\n        const neighbors = []\n        if (!(col-1 < 0))               neighbors.push(grid[row][col-1])\n        if (!(row+1 > grid.length-1))   neighbors.push(grid[row+1][col])\n        if (!(col+1 > grid[0].length-1)) neighbors.push(grid[row][col+1])\n        if (!(row-1 < 0))               neighbors.push(grid[row-1][col])\n\n        for (const neighbor of neighbors) {\n            visitedNodes.push(neighbor)\n            if (neighbor.previousNode == null) {\n                neighbor.previousNode = currentNode\n            }\n        }\n    }\n\n    return ([visitedNodesInOrder, false])\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'bootstrap/dist/css/bootstrap.min.css'\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}